<!--
  This translates mmbase XML, normally containing an objects tag. The XML related to this XSL is generated by
  org.mmbase.bridge.util.Generator, and the XSL is invoked by FormatterTag.

  @author:  Michiel Meeuwissen
  @version: $Id: 2xhtml.xslt,v 1.4 2004-02-11 20:00:08 michiel Exp $
  @since:   MMBase-1.6
-->
<xsl:stylesheet  version = "1.1"
  xmlns:xsl ="http://www.w3.org/1999/XSL/Transform"
  xmlns:node ="org.mmbase.bridge.util.xml.NodeFunction"
  xmlns:mmxf="http://www.mmbase.org/mmxf"
  exclude-result-prefixes="node"
>
  <xsl:import href="mmxf2xhtml.xslt" />   <!-- dealing with mmxf is done there -->
  <xsl:import href="formatteddate.xslt" /><!-- dealing with dates is done there -->


  <xsl:param name="formatter_imgdb" />    <!-- this information is needed to correctly construct img.db urls -->

  <xsl:output method="xml" omit-xml-declaration="yes" /><!-- xhtml is a form of xml -->

  <xsl:variable name="newstype">xmlnews</xsl:variable>
	<!-- I had an 'xmlnews' type... Can easily switch beteen them like
             this.  Perhaps you prefer 'news' itself to contain XML fields. -->

   <!-- If objects is the entrance to this XML, then only handle the root child of it -->
  <xsl:template match="objects">
    <xsl:apply-templates select="object[1]" />
  </xsl:template>

   <!-- how to present a node -->
   <xsl:template match="object">
    <xsl:apply-templates select="field">
    </xsl:apply-templates>
  </xsl:template>


   <!-- how to present a news node -->
   <xsl:template match="object[@type=$newstype and not(unfilledField)]">
     <xsl:apply-templates select="field[@name='title']"    />
     <xsl:apply-templates select="field[@name='subtitle']" />
     <xsl:apply-templates select="field[@name='body']" />
   </xsl:template>


  <xsl:template match="object[@type=$newstype]/field[@name='title']" >
    <h1><xsl:value-of select="." /></h1>
  </xsl:template>

  <xsl:template match="object[@type=$newstype]/field[@name='subtitle']" >
    <h2><xsl:value-of select="." /></h2>
  </xsl:template>


  <xsl:template match="field[@format='xml']">
    <xsl:apply-templates />
  </xsl:template>

  <!-- how to present a nodes that are related to paragraphs. -->
  <xsl:template match="object" mode="concise">
    <xsl:choose>
      <xsl:when test="@type='images'">
        <img src="{node:function(string(./field[@name='number'] ), 'servletpath(,cache(s(100x100)))')}" alt="{./field[@name='description']}" align="right" />
          <!-- Resin's xslt-impl, does not pass 'Nodes', so we limit ourselves to strings. :-( -->
      </xsl:when>
      <xsl:when test="@type='urls'">
        <a href="{field[@name='url']}"><xsl:value-of select="field[@name='description']" /></a><br />
      </xsl:when>
    </xsl:choose>
  </xsl:template>


  <!--how to present nodes that are related to words -->
  <xsl:template match="object" mode="inline">
    <xsl:choose>
      <xsl:when test="@type='images'">
        <a href="{$formatter_imgdb}{./field[@name='number']}" alt="{./field[@name='description']}">plaatje</a>
      </xsl:when>
      <xsl:when test="@type='urls'">
        <a href="{field[@name='url']}"><xsl:value-of select="position()" /></a>
        <xsl:if test="position() &lt; last()"><xsl:text>, </xsl:text></xsl:if>
      </xsl:when>
    </xsl:choose>
  </xsl:template>

  <!-- An anchor can handle only urls links -->
  <xsl:template match="a" mode="sub">
    <xsl:param name="relatednodes" />
    <xsl:variable name="urls" select="$relatednodes[@type='urls']" />
    <xsl:choose>
      <xsl:when test="not($urls)">
        <!-- no relations found, simply ignore the anchor -->
        <xsl:apply-templates />
      </xsl:when>
      <xsl:when test="count($urls)=1">
        <!-- only one url is related, it is simple to make the body clickable -->
        <a href="{$urls/field[@name='url']}"><xsl:apply-templates  /></a>
      </xsl:when>
      <xsl:otherwise>
        <!-- more than one url related to this anchor, we add between parentheses a list of links -->
        <xsl:apply-templates /> (<xsl:apply-templates select="$urls" mode="inline" />)
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>



  <!-- template to override mmxf tags with an 'id', we support links to it here -->
  <xsl:template match="h">
    <xsl:if test="count(ancestor::section)=1">
       <xsl:if test="string(.)"><h3><xsl:value-of select="." /></h3></xsl:if>
    </xsl:if>
    <xsl:if test="count(ancestor::section)=2"><p><b><xsl:value-of select="." /></b></p></xsl:if>
    <xsl:if test="count(ancestor::section)=3"><p><xsl:value-of select="." /></p></xsl:if>
    <xsl:if test="count(ancestor::section)>3"><xsl:value-of select="." /><br /></xsl:if>

    <xsl:copy>

      <!-- store the 'relation' nodes for convenience in $rels:-->
      <xsl:variable name="rels"   select="ancestor::object/relation[@role='idrel']" />

        <!-- also for conveniences: all related nodes to this node-->
      <xsl:variable name="related_to_node"   select="//objects/object[@id=$rels/@related]" />

        <!-- There are two type of relations, it is handy to treat them seperately: -->
      <xsl:variable name="srelations" select="//objects/object[@id=$rels[@type='source']/@object      and field[@name='id'] = current()/@id]" />
      <xsl:variable name="drelations" select="//objects/object[@id=$rels[@type='destination']/@object and field[@name='id'] = current()/@id]" />

        <!-- now link the relationnodes with the nodes related to this node, the find the 'relatednodes' -->
      <xsl:variable name="relatednodes" select="$related_to_node[@id = $srelations/field[@name = 'dnumber']] | $related_to_node[@id = $drelations/field[@name='snumber']]" />

      <xsl:apply-templates select="." mode="sub">
        <xsl:with-param name="relatednodes" select="$relatednodes" />
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>


  <!-- template to override mmxf tags with an 'id', we support links to it here -->
  <xsl:template match="p|a">
    <xsl:copy>

      <!-- store the 'relation' nodes for convenience in $rels:-->
      <xsl:variable name="rels"   select="ancestor::object/relation[@role='idrel']" />

        <!-- also for conveniences: all related nodes to this node-->
      <xsl:variable name="related_to_node"   select="//objects/object[@id=$rels/@related]" />

        <!-- There are two type of relations, it is handy to treat them seperately: -->
      <xsl:variable name="srelations" select="//objects/object[@id=$rels[@type='source']/@object      and field[@name='id'] = current()/@id]" />
      <xsl:variable name="drelations" select="//objects/object[@id=$rels[@type='destination']/@object and field[@name='id'] = current()/@id]" />

        <!-- now link the relationnodes with the nodes related to this node, the find the 'relatednodes' -->
      <xsl:variable name="relatednodes" select="$related_to_node[@id = $srelations/field[@name = 'dnumber']] | $related_to_node[@id = $drelations/field[@name='snumber']]" />

      <xsl:apply-templates select="." mode="sub">
        <xsl:with-param name="relatednodes" select="$relatednodes" />
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>


  <!-- A paragraph can handle images and urls links -->
  <xsl:template match="section|p" mode="sub">
    <xsl:param name="relatednodes" />
    <xsl:apply-templates  select="$relatednodes[@type='images']"  mode="concise" />
    <xsl:apply-templates />
    <xsl:if test="count($relatednodes[@type='urls']) &gt; 0">
      <small><xsl:apply-templates  select="$relatednodes[@type='urls']"  mode="concise" /></small>
    </xsl:if>
  </xsl:template>


</xsl:stylesheet>
